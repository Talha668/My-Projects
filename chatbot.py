# -*- coding: utf-8 -*-
"""Chatbot.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RgGFPuo4PryLOinSOywhNKkP9yOK3krL
"""

# Commented out IPython magic to ensure Python compatibility.
# # @title üè° COMPLETE IMPROVED DHA CHATBOT - INSTALLATION
# %%time
# print("üöÄ Installing Improved DHA Property Chatbot...")
# 
# # Install required packages
# !pip install -q torch transformers datasets sentence-transformers accelerate
# !pip install -q pandas numpy
# 
# print("‚úÖ All packages installed!")
# 
# # Import everything
# import torch
# import numpy as np
# import pandas as pd
# import json
# import re
# import requests
# import random
# from typing import List, Dict, Any
# from pathlib import Path
# from datetime import datetime
# 
# # Import Transformers
# from transformers import (
#     AutoTokenizer,
#     AutoModelForCausalLM,
#     Trainer,
#     TrainingArguments,
#     DataCollatorForLanguageModeling
# )
# from datasets import Dataset
# 
# print("üéØ All imports complete!")

# @title üè¢ IMPROVED DHA PROPERTY HANDLER
class DHAPropertyHandler:
    """Handles DHA property data with PROPER formatting"""

    def __init__(self, api_url: str = "https://api.dhaconnects.com/api/property"):
        self.api_url = api_url
        self.headers = {'User-Agent': 'DHA-Chatbot/1.0'}

    def fetch_properties(self) -> List[Dict]:
        """Fetch properties from DHA API"""
        print(f"üåê Fetching from: {self.api_url}")

        try:
            response = requests.get(self.api_url, headers=self.headers, timeout=30)

            if response.status_code == 200:
                data = response.json()

                # Handle different response formats
                if isinstance(data, list):
                    properties = data
                    print(f"‚úÖ Found {len(properties)} properties in list")
                elif isinstance(data, dict):
                    # Try common keys
                    for key in ['data', 'properties', 'results', 'items']:
                        if key in data and isinstance(data[key], list):
                            properties = data[key]
                            print(f"‚úÖ Found {len(properties)} properties in '{key}' key")
                            break
                    else:
                        # Single property
                        properties = [data]
                        print("‚úÖ Found 1 property")
                else:
                    properties = []
                    print("‚ö†Ô∏è  No properties found")

                # Clean and validate properties
                cleaned_properties = []
                for prop in properties:
                    if isinstance(prop, dict):
                        # Clean the property data
                        cleaned = self.clean_property(prop)
                        if cleaned:  # Only add if we have basic info
                            cleaned_properties.append(cleaned)

                print(f"üìä Processing {len(cleaned_properties)} valid properties")
                return cleaned_properties

            else:
                print(f"‚ö†Ô∏è API error {response.status_code}")
                return self.get_sample_properties()

        except Exception as e:
            print(f"‚ùå Failed to fetch: {e}")
            return self.get_sample_properties()

    def clean_property(self, prop: Dict) -> Dict:
        """Clean individual property data"""
        cleaned = {}

        # Clean title
        if 'title' in prop:
            cleaned['title'] = str(prop['title']).strip().replace('|', '-').replace('\n', ' ')
        elif 'name' in prop:
            cleaned['title'] = str(prop['name']).strip().replace('|', '-').replace('\n', ' ')
        else:
            cleaned['title'] = "DHA Property"

        # Clean description
        if 'description' in prop and prop['description']:
            desc = str(prop['description']).strip()
            if len(desc) > 100:
                desc = desc[:100] + "..."
            cleaned['description'] = desc.replace('|', ', ').replace('\n', ' ')
        else:
            cleaned['description'] = "No description available"

        # Clean price (convert to integer)
        if 'price' in prop:
            price = self.clean_price(prop['price'])
            cleaned['price'] = price
        else:
            cleaned['price'] = 0

        # Clean location
        if 'location' in prop:
            cleaned['location'] = str(prop['location']).strip().replace('|', ', ').replace('\n', ' ')
        elif 'address' in prop:
            cleaned['location'] = str(prop['address']).strip().replace('|', ', ').replace('\n', ' ')
        else:
            cleaned['location'] = "DHA Lahore"

        # Clean other fields
        for field in ['property_type', 'type', 'area', 'size', 'phase', 'sector', 'plot_no', 'status']:
            if field in prop and prop[field]:
                cleaned[field] = str(prop[field]).strip().replace('|', ', ').replace('\n', ' ')

        return cleaned

    def clean_price(self, price_value: Any) -> int:
        """Convert any price format to integer"""
        if price_value is None:
            return 0

        if isinstance(price_value, (int, float)):
            return int(price_value)

        if isinstance(price_value, str):
            # Remove everything except numbers and dots
            cleaned = re.sub(r'[^\d.]', '', price_value)
            if cleaned:
                try:
                    return int(float(cleaned))
                except:
                    return 0

        return 0

    def get_sample_properties(self) -> List[Dict]:
        """Sample DHA property data for testing"""
        return [
            {
                "title": "DHA Phase 8 - 5 Marla Corner Plot",
                "description": "Premium corner plot facing park, ideal for construction",
                "price": 35000000,
                "location": "DHA Phase 8, Lahore",
                "property_type": "Plot",
                "area": "5 Marla",
                "phase": "Phase 8",
                "sector": "Sector B",
                "plot_no": "C-12",
                "status": "Available"
            },
            {
                "title": "DHA Phase 6 - 10 Marla Luxury House",
                "description": "Modern house with garden and security",
                "price": 120000000,
                "location": "DHA Phase 6, Lahore",
                "property_type": "House",
                "area": "10 Marla",
                "phase": "Phase 6",
                "bedrooms": 4,
                "status": "Available"
            },
            {
                "title": "DHA Phase 7 - 7 Marla Commercial Plot",
                "description": "Commercial plot on main boulevard",
                "price": 75000000,
                "location": "DHA Phase 7, Lahore",
                "property_type": "Commercial",
                "area": "7 Marla",
                "phase": "Phase 7",
                "status": "Available"
            }
        ]

# @title üìö IMPROVED TRAINING DATA GENERATOR
class ImprovedTrainingDataGenerator:
    """Generates HIGH-QUALITY training data for accurate responses"""

    def generate_high_quality_data(self, properties: List[Dict]) -> List[str]:
        """Generate training data that produces COHERENT English responses"""
        training_examples = []

        # 1. HIGH-QUALITY Basic Conversations
        basic_conversations = [
            # Greetings
            ("Hello", "Hello! I'm your DHA property assistant. How can I help you today?"),
            ("Hi", "Hi there! I specialize in DHA Lahore properties. What information do you need?"),
            ("Good morning", "Good morning! I'm here to help you with DHA property information."),
            ("Good afternoon", "Good afternoon! How can I assist you with DHA properties today?"),

            # Help requests
            ("Help", "I can help you with: 1) Finding plots by size 2) Checking prices 3) Searching by DHA phase 4) Property availability information. What would you like to know?"),
            ("What can you do?", "I can help you find DHA properties, check prices, compare locations, and provide property details. What specifically are you looking for?"),

            # Polite responses
            ("Thank you", "You're welcome! Let me know if you need more information about DHA properties."),
            ("Thanks", "You're welcome! Feel free to ask if you have more questions."),
            ("Okay", "Is there anything else you would like to know about DHA properties?"),

            # Exit
            ("Bye", "Goodbye! Thank you for using our DHA property service."),
            ("Goodbye", "Goodbye! Have a great day."),
        ]

        for question, answer in basic_conversations:
            training_examples.append(f"User: {question}\nAssistant: {answer}")

        # 2. Property-Specific HIGH-QUALITY Training
        for prop in properties:
            # Extract clean information
            title = prop.get('title', 'DHA Property')
            price = prop.get('price', 0)
            location = prop.get('location', 'DHA Lahore')
            area = prop.get('area', '')
            phase = prop.get('phase', '')
            prop_type = prop.get('property_type', 'Plot')

            # Format price for readability
            price_str = self.format_price_readable(price)

            # Create NATURAL English Q&A pairs
            property_qna = [
                # General property questions
                (f"What properties do you have available?",
                 f"We have various DHA properties available. One example is {title} located in {location}."),

                (f"Tell me about {title}",
                 f"{title} is located in {location}. It is a {area} {prop_type.lower()} property."),

                (f"Can you describe {title}?",
                 f"{title} is a {area} {prop_type.lower()} property in {location}. {self.get_description_snippet(prop)}"),

                # Price inquiries
                (f"What is the price of {title}?",
                 f"{title} is priced at {price_str}."),

                (f"How much does {title} cost?",
                 f"The cost for {title} is {price_str}."),

                (f"What's the price for a {area} {prop_type.lower()}?",
                 f"For a {area} {prop_type.lower()} like {title}, the price is typically around {price_str}."),

                # Location inquiries
                (f"Where is {title} located?",
                 f"{title} is located in {location}."),

                (f"Which area is {title} in?",
                 f"{title} is situated in {location}."),

                # Size inquiries
                (f"What size is {title}?",
                 f"{title} is a {area} property."),

                (f"How big is {title}?",
                 f"{title} covers an area of {area}."),

                # Phase inquiries
                (f"Which DHA phase is {title} in?",
                 f"{title} is located in {phase if phase else 'a DHA phase'}."),

                (f"Is {title} in {phase}?",
                 f"Yes, {title} is located in {phase}." if phase else f"{title} is in a DHA phase in Lahore."),

                # Availability
                (f"Is {title} available?",
                 f"Yes, {title} is currently available for purchase."),

                (f"What's the status of {title}?",
                 f"{title} is currently available for purchase."),
            ]

            # Filter and add only good quality examples
            for question, answer in property_qna:
                if (len(answer) > 30 and  # Minimum length
                    '.' in answer and      # Complete sentence
                    not any(bad_word in answer.lower() for bad_word in ['|', 'undefined', 'null', 'none']) and
                    len(answer.split()) > 5):  # Multiple words
                    training_examples.append(f"User: {question}\nAssistant: {answer}")

        # 3. DHA-Specific Conversations
        dha_conversations = [
            """User: I'm looking for a plot in DHA Lahore
Assistant: I can help you find plots in DHA Lahore. What size plot are you interested in?
User: 5 Marla plot
Assistant: We have 5 Marla plots available in various DHA phases. The price typically ranges from PKR 3 to 4 crore depending on the phase and location.""",

            """User: What is available in Phase 8?
Assistant: In Phase 8, we have various plots and houses available. Prices for plots start from around PKR 3.5 crore for 5 Marla plots.""",

            """User: Show me commercial properties
Assistant: We have commercial plots available in several DHA phases. Commercial properties are ideal for business use and are typically priced higher than residential plots.""",

            """User: Price of 10 Marla house
Assistant: 10 Marla houses in DHA typically range from PKR 10 to 15 crore, depending on the phase, location, and amenities. Would you like specific property details?""",

            """User: Available plots in Phase 6
Assistant: In Phase 6, we have plots available in various sizes. Phase 6 is a well-developed area with good infrastructure and amenities.""",
        ]

        training_examples.extend(dha_conversations)

        # 4. Common follow-up questions
        follow_up_qa = [
            ("What about Phase 5?", "Phase 5 also has properties available. It's a well-established phase with good amenities."),
            ("Any discount?", "Prices are typically fixed for DHA properties, but you can discuss specific terms with the property dealer."),
            ("When can I visit?", "Site visits can be arranged through our property dealers. Would you like me to connect you with one?"),
            ("Payment plan?", "Most DHA properties offer installment plans. The specific terms would depend on the property and phase."),
            ("Legal papers?", "All DHA properties come with proper legal documentation and titles."),
        ]

        for question, answer in follow_up_qa:
            training_examples.append(f"User: {question}\nAssistant: {answer}")

        # Shuffle for better training
        random.shuffle(training_examples)

        print(f"‚úÖ Generated {len(training_examples)} HIGH-QUALITY training examples")

        # Show samples
        print("\nüìÑ Sample training examples (first 3):")
        for i in range(min(3, len(training_examples))):
            print(f"\nExample {i+1}:")
            lines = training_examples[i].split('\n')
            for line in lines:
                print(f"  {line}")

        return training_examples

    def format_price_readable(self, price: int) -> str:
        """Format price in readable English"""
        if price <= 0:
            return "Price information not available"

        if price >= 10000000:  # 1 crore
            crore = price / 10000000
            if crore.is_integer():
                return f"PKR {int(crore)} crore"
            else:
                return f"PKR {crore:.1f} crore"
        elif price >= 100000:  # 1 lakh
            lakh = price / 100000
            if lakh.is_integer():
                return f"PKR {int(lakh)} lakh"
            else:
                return f"PKR {lakh:.1f} lakh"
        else:
            return f"PKR {price:,}"

    def get_description_snippet(self, prop: Dict) -> str:
        """Get a natural description snippet"""
        desc = prop.get('description', '')
        if len(desc) > 80:
            return desc[:80] + "..."
        return desc if desc else "This property offers good value for investment."

# @title ü§ñ IMPROVED CHATBOT TRAINER
class ImprovedChatbotTrainer:
    """Trainer optimized for ACCURATE English responses"""

    def __init__(self, model_name: str = "microsoft/DialoGPT-small"):
        print(f"ü§ñ Initializing improved trainer with {model_name}")

        # Load tokenizer and model
        self.tokenizer = AutoTokenizer.from_pretrained(model_name)
        self.model = AutoModelForCausalLM.from_pretrained(model_name)

        # Configure tokenizer PROPERLY
        if self.tokenizer.pad_token is None:
            self.tokenizer.pad_token = self.tokenizer.eos_token

        # Set padding side
        self.tokenizer.padding_side = "left"

        # Move to GPU if available
        self.device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
        self.model.to(self.device)

        print(f"‚úÖ Model loaded on {self.device}")
        print(f"üìè Tokenizer vocab size: {self.tokenizer.vocab_size}")

    def prepare_quality_dataset(self, training_data: List[str]) -> Dataset:
        """Prepare HIGH-QUALITY dataset for training"""
        print(f"üìö Preparing dataset from {len(training_data)} examples")

        # Tokenize with PROPER settings
        tokenized = self.tokenizer(
            training_data,
            truncation=True,
            padding="max_length",
            max_length=256,  # Optimal for conversations
            return_tensors="pt"
        )

        # Create dataset
        dataset = Dataset.from_dict({
            'input_ids': tokenized['input_ids'],
            'attention_mask': tokenized['attention_mask'],
            'labels': tokenized['input_ids'].clone()
        })

        # Show dataset info
        print(f"‚úÖ Dataset created: {len(dataset)} examples")
        print(f"üìè Sequence length: {tokenized['input_ids'].shape[1]}")

        return dataset

    def train_for_accuracy(self, dataset: Dataset, output_dir: str = "/content/dha_chatbot_improved"):
        """Train with settings optimized for ACCURACY"""
        print("üéØ Starting accuracy-optimized training...")

        # OPTIMAL TrainingArguments for accurate responses
        training_args = TrainingArguments(
            output_dir=output_dir,
            num_train_epochs=4,  # Optimal for convergence
            per_device_train_batch_size=4,
            warmup_steps=100,
            weight_decay=0.01,
            logging_dir=f"{output_dir}/logs",
            logging_steps=25,
            save_steps=100,
            save_total_limit=2,
            learning_rate=2e-5,  # Lower for better accuracy
            fp16=torch.cuda.is_available(),
            gradient_accumulation_steps=1,
            report_to="none",
            overwrite_output_dir=True,
            save_strategy="steps",
            prediction_loss_only=True,
            load_best_model_at_end=False,
            greater_is_better=False,
            metric_for_best_model="loss",
            remove_unused_columns=True,
        )

        # Data collator
        data_collator = DataCollatorForLanguageModeling(
            tokenizer=self.tokenizer,
            mlm=False  # Causal language modeling
        )

        # Create trainer
        trainer = Trainer(
            model=self.model,
            args=training_args,
            train_dataset=dataset,
            data_collator=data_collator,
        )

        # Train with progress
        print("üî• Training started...")
        trainer.train()

        # Save model
        trainer.save_model()
        self.tokenizer.save_pretrained(output_dir)

        print(f"\n‚úÖ Training completed successfully!")
        print(f"üíæ Model saved to: {output_dir}")

        return True

# @title üè† ACCURATE DHA CHATBOT - FIXED VERSION
class AccurateDHAChatbot:
    """Chatbot that produces ACCURATE, COHERENT English responses - FIXED"""

    def __init__(self, model_path: str = None):
        print("üè† Loading Accurate DHA Chatbot...")

        # Load model (trained or base)
        if model_path and Path(model_path).exists():
            self.tokenizer = AutoTokenizer.from_pretrained(model_path)
            self.model = AutoModelForCausalLM.from_pretrained(model_path)
            print(f"‚úÖ Loaded ACCURATELY trained model from {model_path}")
        else:
            self.tokenizer = AutoTokenizer.from_pretrained("microsoft/DialoGPT-small")
            self.model = AutoModelForCausalLM.from_pretrained("microsoft/DialoGPT-small")
            print("‚úÖ Using base model (will be trained)")

        # Configure tokenizer
        if self.tokenizer.pad_token is None:
            self.tokenizer.pad_token = self.tokenizer.eos_token

        # Move to device
        self.device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
        self.model.to(self.device)
        self.model.eval()

        print(f"ü§ñ Chatbot initialized on {self.device}")
        print("üí° This chatbot is optimized for ACCURATE English responses")

    def create_intelligent_context(self, query: str, properties: List[Dict]) -> str:
        """Create SHORTER intelligent context to avoid length issues"""
        query_lower = query.lower()

        # Find MOST relevant property (just 1 to keep context short)
        best_prop = None
        best_score = 0

        for prop in properties:
            score = 0

            # Simple matching
            title = prop.get('title', '').lower()

            if '5 marla' in query_lower and '5 marla' in title:
                score += 3
            if '10 marla' in query_lower and '10 marla' in title:
                score += 3
            if 'phase 8' in query_lower and 'phase 8' in title:
                score += 2
            if 'phase 6' in query_lower and 'phase 6' in title:
                score += 2
            if 'plot' in query_lower and 'plot' in title:
                score += 1

            if score > best_score:
                best_score = score
                best_prop = prop

        # Build SHORT context
        if best_prop and best_score > 0:
            title = best_prop.get('title', 'DHA Property')
            price = best_prop.get('price', 0)
            location = best_prop.get('location', 'DHA Lahore')
            area = best_prop.get('area', '')

            # Format price briefly
            if price >= 10000000:
                price_str = f"PKR {price/10000000:.1f} crore"
            elif price >= 100000:
                price_str = f"PKR {price/100000:.1f} lakh"
            else:
                price_str = f"PKR {price:,}"

            return f"{title} in {location}. Size: {area}. Price: {price_str}."
        else:
            # Very short general context
            if len(properties) > 0:
                sample = properties[0]
                return f"DHA properties available. Example: {sample.get('title', 'Property')}."
            return "DHA Lahore properties available."

    def generate_accurate_response(self, query: str, properties: List[Dict]) -> str:
        """Generate ACCURATE, COHERENT English response - FIXED LENGTH"""
        # Create SHORT context
        context = self.create_intelligent_context(query, properties)

        # SHORT prompt to avoid length issues
        prompt = f"""DHA Property Info: {context}

Question: {query}

Answer clearly and accurately:"""

        # Tokenize
        inputs = self.tokenizer.encode(prompt, return_tensors="pt")
        inputs = inputs.to(self.device)

        # Generate with FIXED parameters
        with torch.no_grad():
            outputs = self.model.generate(
                inputs,
                max_new_tokens=150,  # FIXED: Use max_new_tokens
                temperature=0.3,
                top_p=0.9,
                top_k=30,
                do_sample=True,
                pad_token_id=self.tokenizer.eos_token_id,
                no_repeat_ngram_size=2,
                repetition_penalty=1.2,
                num_beams=2,
                early_stopping=True,
            )

        # Decode
        response = self.tokenizer.decode(outputs[0], skip_special_tokens=True)

        # Extract just the answer part
        if "Answer clearly and accurately:" in response:
            response = response.split("Answer clearly and accurately:")[-1].strip()

        # Clean up
        response = self.clean_response(response)

        return response

    def clean_response(self, response: str) -> str:
        """Clean and format the response"""
        # Remove prompt if still there
        for marker in ["DHA Property Info:", "Question:", "Answer clearly and accurately:"]:
            if marker in response:
                response = response.split(marker)[-1].strip()

        # Ensure proper ending
        if response and not response.endswith(('.', '!', '?')):
            response = response + '.'

        # Capitalize
        if response and len(response) > 1:
            response = response[0].upper() + response[1:]

        return response

    def test_accuracy(self, properties: List[Dict]):
        """Test the chatbot's accuracy - FIXED VERSION"""
        print("\n" + "="*70)
        print("üß™ ACCURACY TEST - DHA CHATBOT")
        print("="*70)

        # Use FEWER properties to keep context short
        test_properties = properties[:3]

        test_cases = [
            ("Hello", "greeting"),
            ("What DHA properties do you have?", "general"),
            ("5 Marla plot price", "specific"),
            ("Phase 8 properties", "phase"),
        ]

        for query, test_type in test_cases:
            print(f"\nüîç Test: {test_type.upper()}")
            print(f"üë§ User: {query}")
            print("-"*50)
            try:
                response = self.generate_accurate_response(query, test_properties)
                print(f"ü§ñ Assistant: {response}")

                # Quality check
                word_count = len(response.split())
                if word_count >= 5 and any(punct in response for punct in ['.', '!', '?']):
                    print("‚úÖ Good response")
                else:
                    print(f"‚ö†Ô∏è  Short response ({word_count} words)")

            except Exception as e:
                print(f"‚ùå Error: {e}")
                print("ü§ñ Assistant: I apologize, I encountered an error. Please try a simpler question.")

    def interactive_chat(self, properties: List[Dict]):
        """Interactive chat interface - FIXED"""
        print("\n" + "="*70)
        print("üè° DHA LAHORE - PROPERTY EXPERT CHAT")
        print("="*70)
        print("\nI am your DHA property assistant.")
        print("\nPlease ask simple questions like:")
        print("  ‚Ä¢ 'Hello'")
        print("  ‚Ä¢ '5 Marla plot price'")
        print("  ‚Ä¢ 'Phase 8 properties'")
        print("\nType 'quit' to exit\n")
        print("-"*70)

        # Use fewer properties for faster responses
        chat_properties = properties[:5]

        while True:
            user_input = input("\nüë§ You: ").strip()

            if not user_input:
                continue

            if user_input.lower() == 'quit':
                print("\nü§ñ Thank you! Goodbye! üè°")
                break

            if user_input.lower() == 'help':
                print("\nü§ñ Ask me about:")
                print("  ‚Ä¢ Property prices")
                print("  ‚Ä¢ Plot sizes (5 Marla, 10 Marla)")
                print("  ‚Ä¢ DHA phases")
                print("  ‚Ä¢ Property availability")
                continue

            print("ü§ñ Assistant: ", end="", flush=True)
            try:
                response = self.generate_accurate_response(user_input, chat_properties)
                print(response)
            except Exception as e:
                print(f"I apologize, I encountered an error. Please try a simpler question.")

# @title üöÄ MAIN PIPELINE - COMPLETE ACCURATE CHATBOT
print("="*80)
print("üöÄ DHA PROPERTY CHATBOT - ACCURATE ENGLISH VERSION")
print("="*80)
print("\nThis version produces CLEAR, ACCURATE English responses")
print("Training with HIGH-QUALITY data to avoid gibberish\n")

# Step 1: Fetch DHA properties
print("\n" + "="*40)
print("1Ô∏è‚É£  FETCHING DHA PROPERTIES")
print("="*40)

handler = DHAPropertyHandler()
properties = handler.fetch_properties()

print(f"\nüìä Total properties to work with: {len(properties)}")

# Show property samples
print("\nüìÑ Property samples:")
for i, prop in enumerate(properties[:2]):
    print(f"\nProperty {i+1}:")
    print(f"  Title: {prop.get('title', 'N/A')}")
    print(f"  Price: PKR {prop.get('price', 0):,}")
    print(f"  Location: {prop.get('location', 'N/A')}")

# Step 2: Generate HIGH-QUALITY training data
print("\n\n" + "="*40)
print("2Ô∏è‚É£  GENERATING HIGH-QUALITY TRAINING DATA")
print("="*40)

generator = ImprovedTrainingDataGenerator()
training_data = generator.generate_high_quality_data(properties)

print(f"\n‚úÖ Generated {len(training_data)} quality training examples")

# Step 3: Train with IMPROVED trainer
print("\n\n" + "="*40)
print("3Ô∏è‚É£  TRAINING FOR ACCURACY")
print("="*40)

trainer = ImprovedChatbotTrainer()
dataset = trainer.prepare_quality_dataset(training_data)

print("\nüî• Training started (this may take 5-10 minutes)...")
success = trainer.train_for_accuracy(dataset, "/content/dha_chatbot_accurate")

if success:
    print("\n‚úÖ Training completed successfully!")
else:
    print("\n‚ö†Ô∏è  Training had issues, but continuing...")

# Step 4: Create and test ACCURATE chatbot
print("\n\n" + "="*40)
print("4Ô∏è‚É£  CREATING ACCURATE CHATBOT")
print("="*40)

chatbot = AccurateDHAChatbot("/content/dha_chatbot_accurate")

print("\n" + "="*80)
print("üéâ ACCURATE DHA CHATBOT READY!")
print("="*80)

# Initial test
print("\nüß™ Initial accuracy test...")
chatbot.test_accuracy(properties)

# Interactive chat option
print("\n" + "="*80)
print("üí¨ START INTERACTIVE CHAT")
print("="*80)

response = input("\nStart interactive chat with accurate chatbot? (yes/no): ").strip().lower()

if response in ['yes', 'y', 'yeah']:
    chatbot.interactive_chat(properties)
else:
    print("\n‚úÖ Chatbot is ready! You can run these commands later:")
    print(f"""\n# To start chat:
chatbot.interactive_chat(properties)

# To test accuracy:
chatbot.test_accuracy(properties)

# To generate single response:
response = chatbot.generate_accurate_response("Your question", properties)
print(response)""")

print("\n" + "="*80)
print("üè° DHA PROPERTY CHATBOT - DEPLOYMENT READY")
print("="*80)